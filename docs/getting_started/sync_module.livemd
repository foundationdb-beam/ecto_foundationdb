# Sync Engine Part III - Removing boilerplate

```elixir
Mix.install([
  {:phoenix_playground, "~> 0.1"},
  {:phoenix_ecto, "~> 4.7"},
  {:ecto_foundationdb, github: "jessestimpson/ecto_foundationdb", branch: "sync"}
])
```

## Intro

Using [FoundationDB Watches](https://hexdocs.pm/ecto_foundationdb/Ecto.Adapters.FoundationDB.html#module-watches), we can set up a lightweight Sync Engine for database reads. It will automatically propagate new data to all mounted LiveViews with push-messaging delivered from the database directly to the LiveView process, without using PubSub.

This is Part III, where capture the ideas from I and II into a module that removes as much boilerplate as possible, and keeps your LiveView lean, while maintaining clear data access semantics.

## Setup Ecto

First, we set up Ecto, defining a schema, and starting the Repo. Our app will have a product catalog and each Product may have zero or more Reviews.

```elixir
defmodule Product do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: false}

  schema "products" do
    field(:name, :string)
    field(:description, :string)
    timestamps()
  end

  def changeset(product, params \\ %{}) do
    Changeset.cast(product, params, [:name, :description])
  end
end

defmodule Review do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}

  schema "reviews" do
    belongs_to(:product, Product, type: :binary_id)
    field(:author, :string)
    field(:content, :string)
    field(:score, :integer)
    timestamps()
  end

  def changeset(review, params \\ %{}) do
    Changeset.cast(review, params, [:author, :content, :score])
  end
end

defmodule Migration1 do
  use EctoFoundationDB.Migration

  @impl true
  def change() do
    [
      create(metadata(Product)),
      create(index(Product, [:name])),
      create(metadata(Review)),
      create(index(Review, [:product_id, :inserted_at])),
      create(metadata(Review, [:product_id]))
    ]
  end
end

defmodule Repo do
  use Ecto.Repo, otp_app: :my_app, adapter: Ecto.Adapters.FoundationDB

  use EctoFoundationDB.Migrator

  @impl true
  def migrations(), do: [
    {1, Migration1}
  ]
end

# ------------------------------------------------------------------
# This section contains some set-up within Livebook that's typically
# handled instead in your application startup and config.
Application.put_env(:my_app, Repo,
  open_db: &EctoFoundationDB.Sandbox.open_db/1,
  storage_id: EctoFoundationDB.Sandbox
)

{:ok, _} = Ecto.Adapters.FoundationDB.ensure_all_started(Repo.config(), :temporary)
Repo.start_link(log: false)
# ------------------------------------------------------------------

alias EctoFoundationDB.Tenant

Tenant.clear_delete!(Repo, "sync-sample")
tenant = Tenant.open_empty!(Repo, "sync-sample")

```

Next, we create a product and some reviews.

```elixir
{widget, widget_reviews} = 
  Repo.transactional(tenant, fn ->
  widget = Repo.insert!(
          %Product{id: "p1", name: "Widget", description: "You want to buy this!"}
        )
  r = [
        %Review{product: widget, author: "Alice", content: "It's ok", score: 3},
        %Review{product: widget, author: "Bob", content: "It's great!", score: 5}
      ]
  {widget, for(x <- r, do: Repo.insert!(x))}
end)
```

```elixir
{blivet, blivet_reviews} = 
  Repo.transactional(tenant, fn ->
  blivet = Repo.insert!(
          %Product{id: "p2", name: "Blivet", description: "It's pretty useful"}
        )
  r = [
        %Review{product: blivet, author: "Charlie", content: "The blivet is supreme", score: 5},
        %Review{product: blivet, author: "Dan", content: "This blivet is useless!", score: 1}
      ]
  {blivet, for(x <- r, do: Repo.insert!(x))}
end)
```

## Setup LiveView

Let's define a simple CSS stylesheet for our page. The values chosen here are not important for this demo.

```elixir
defmodule Style do
  def style(), do: """
<style type="text/css">
  /* Global Resets & Layout */
  body { font-family: sans-serif; line-height: 1.5; color: #333; }

  /* Navigation Bar */
  .catalog ul {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 1rem;
    list-style: none;
    background: #f4f4f4;
    border-bottom: 1px solid #ddd;
  }
  .catalog a { text-decoration: none; color: #007bff; font-weight: bold; }
  .catalog a:hover { text-decoration: underline; }

  /* Product Card */
  .card {
    max-width: 500px;
    margin: 2rem auto;
    padding: 2rem;
    border: 1px solid #eee;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }

  .card h1 { text-align: center; margin-top: 0; }
  .card p { text-align: center; color: #666; }

  /* Reviews Section */
  .card ul { padding: 0; list-style: none; }
  .card figure {
    margin: 1.5rem 0;
    padding: 1rem;
    background: #fafafa;
    border-left: 4px solid #007bff;
  }
  blockquote { margin: 0; font-style: italic; }
  figcaption { text-align: right; font-weight: bold; font-size: 0.9rem; }

  .page-title {
    text-align: center;
    margin: 2rem 0;
    font-size: 2rem;
    color: #222;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
</style>
"""
end
```

With the stylesheet out of the way, we can showcase how the Sync module works in your LiveView.

```elixir
defmodule DemoLive do
  use Phoenix.LiveView

  alias EctoFoundationDB.Sync
  import Ecto.Query

  @query_catalog from(p in Product, order_by: p.name)
  @query_reviews from(r in Review, order_by: {:desc, r.inserted_at})

  require Logger
  def mount(_params, _session, socket) do
    tenant = Tenant.open!(Repo, "sync-sample")

    {:ok, socket
      |> put_private(:tenant, tenant)
      |> Sync.sync_all!(Repo, :catalog, @query_catalog)}
  end

  def handle_params(%{"id" => id}, _uri, socket) do
    {:noreply, 
      socket
      |> Sync.sync_one!(Repo, :product, Product, id)
      |> Sync.sync_all_by!(Repo, :reviews, @query_reviews, product_id: id)}
  end
  def handle_params(_params, _uri, socket),
    do: {:noreply, assign(socket, product: nil, reviews: [])}

  def render(assigns) do
    ~H"""
    <h1 class="page-title">Catalog</h1>
    <div class="catalog">
      <ul>
        <li :for={p <- @catalog}>
          <.link patch={"/?id=#{p.id}"}>{p.name}</.link>
        </li>
      </ul>
    </div>
    <div :if={@product} class="card">
      <h1>{@product.name}</h1>
      <p>{@product.description}</p>
      <ul>
        <li :for={r <- @reviews}>
          <figure>
            <blockquote>({ r.score } stars) { r.content }</blockquote>
            <h3><figcaption>- { r.author }</figcaption></h3>
          </figure>
        </li>
      </ul>
    </div>

    {Phoenix.HTML.raw(Style.style())}
    """
  end

end

PhoenixPlayground.start(live: DemoLive)
```

Now we can add anything to our database, and the page will update.

```elixir
foo = Repo.insert!(
  %Product{id: "p3", name: "Foo", description: "Hello world!"},
  prefix: tenant
)
```

```elixir
Repo.insert(%Review{product: foo, author: "Ethan", content: "Test", score: 3}, prefix: tenant)
```

### LiveComponents

Next, we're going to add another route to our phoenix app, so let's restart the `:phoenix_playground` to get a clean slate.

```elixir
Application.stop(:phoenix_playground)
Application.start(:phoenix_playground)
```

Our app needs an admin page, where we can modify product details. We're going to use LiveComponents for this part of the demo.

```elixir
defmodule ProductAdminCard do
  use Phoenix.LiveComponent
  require Logger

  def update(assigns, socket) do
    {:ok,
      socket
      |> assign(assigns)
      |> assign(form: to_form(Product.changeset(assigns.product)))}
  end

  def handle_event("save", %{"product" => params}, socket) do
    Logger.info("save #{inspect(params)}")
    changeset = Product.changeset(socket.assigns.product, params)
    Logger.info("cs #{inspect(changeset)}")
    res = Repo.update!(changeset)
    Logger.info("res #{inspect(res)}")
    {:noreply, socket}
  end

  def render(assigns) do
    ~H"""
    <div class="card">
      <.form
        for={@form}
        id={"product-form-#{@product.id}"}
        phx-submit="save"
        phx-target={@myself}
      >
        <.input type="text" field={@form[:name]} />
        <.input type="text" field={@form[:description]} />
        <button>Save</button>
      </.form>
    </div>
    """
  end

  attr :field, Phoenix.HTML.FormField
  attr :rest, :global, include: ~w(type)
  defp input(assigns) do
    ~H"""
    <input id={@field.id} name={@field.name} value={@field.value} {@rest} />
    """
  end
end

defmodule DemoAdminLive do
    use Phoenix.LiveView

  alias EctoFoundationDB.Sync
  import Ecto.Query

  require Logger

  @query_catalog from(p in Product, select: p.id, order_by: p.inserted_at)

  def mount(_params, _session, socket) do
    tenant = Tenant.open!(Repo, "sync-sample")

    {:ok, socket
      |> put_private(:tenant, tenant)
      |> Sync.attach_callback(Repo, :sync_products, :on_assigns, &sync_products/2)
      |> Sync.sync_all!(Repo, :catalog, @query_catalog, watch_action: :collection)}
  end

  def sync_products(socket, [:catalog]) do
    id_assigns = for p <- socket.assigns.catalog,
      do: {[:products, p], Product, p}
    Logger.info("ID ASSIGNS #{inspect(id_assigns)}")
    {:halt, Sync.sync_many!(socket, Repo, id_assigns)}
  end
  def sync_products(socket, _) do
    {:cont, socket}
  end

  def render(assigns) do
    ~H"""
    <h1 class="page-title">Admin</h1>
    {inspect(@products)}

    <div :for={{_, p} <- @products}>
      <.live_component
          module={ProductAdminCard}
          id={p.id}
          product={p} />
    </div>

    {Phoenix.HTML.raw(Style.style())}
    """
  end
end

defmodule DemoRouter do
  use Phoenix.Router
  import Phoenix.LiveView.Router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :put_root_layout, html: {PhoenixPlayground.Layout, :root}
    plug :put_secure_browser_headers
  end

  scope "/" do
    pipe_through :browser

    live "/", DemoLive
    live "/admin", DemoAdminLive
  end
end

PhoenixPlayground.start(plug: DemoRouter)
```

```elixir
import Ecto.Query
Repo.all(from(p in Product, select: p.id, order_by: p.inserted_at), prefix: tenant)
```
