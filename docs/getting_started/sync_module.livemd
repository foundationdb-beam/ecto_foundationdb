# Sync Engine Part III - Removing boilerplate

```elixir
Mix.install([
  {:phoenix_playground, "~> 0.1"},
  {:phoenix_ecto, "~> 4.7"},
  {:ecto_foundationdb, github: "jessestimpson/ecto_foundationdb", branch: "sync"}
])
```

## Intro

Using [FoundationDB Watches](https://hexdocs.pm/ecto_foundationdb/Ecto.Adapters.FoundationDB.html#module-watches), we can set up a lightweight Sync Engine for database reads. It will automatically propagate new data to all mounted LiveViews with push-messaging delivered from the database directly to the LiveView process, without using PubSub.

This is Part III, where capture the ideas from I and II into a module that removes as much boilerplate as possible, and keeps your LiveView lean, while maintaining clear data access semantics.

## Setup Ecto

First, we set up Ecto, defining a schema, and starting the Repo. Our app will have a product catalog and each Product may have zero or more Reviews.

```elixir
defmodule Product do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: false}

  schema "products" do
    field(:name, :string)
    field(:description, :string)
    timestamps()
  end

  def changeset(product, params \\ %{}) do
    Changeset.cast(product, params, [:name, :description])
  end
end

defmodule Review do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}

  schema "reviews" do
    belongs_to(:product, Product, type: :binary_id)
    field(:author, :string)
    field(:content, :string)
    field(:score, :integer)
    timestamps()
  end

  def changeset(review, params \\ %{}) do
    Changeset.cast(review, params, [:author, :content, :score])
  end
end

defmodule Migration1 do
  use EctoFoundationDB.Migration

  @impl true
  def change() do
    [
      create(metadata(Product)),
      create(index(Product, [:name])),
      create(metadata(Review)),
      create(index(Review, [:product_id, :inserted_at])),
      create(metadata(Review, [:product_id]))
    ]
  end
end

defmodule Repo do
  use Ecto.Repo, otp_app: :my_app, adapter: Ecto.Adapters.FoundationDB

  use EctoFoundationDB.Migrator

  @impl true
  def migrations(), do: [
    {1, Migration1}
  ]
end

# ------------------------------------------------------------------
# This section contains some set-up within Livebook that's typically
# handled instead in your application startup and config.
Application.put_env(:my_app, Repo,
  open_db: &EctoFoundationDB.Sandbox.open_db/1,
  storage_id: EctoFoundationDB.Sandbox
)

{:ok, _} = Ecto.Adapters.FoundationDB.ensure_all_started(Repo.config(), :temporary)
Repo.start_link(log: false)
# ------------------------------------------------------------------

alias EctoFoundationDB.Tenant

Tenant.clear_delete!(Repo, "sync-sample")
tenant = Tenant.open_empty!(Repo, "sync-sample")

```

Next, we create a product and some reviews.

```elixir
{widget, widget_reviews} = 
  Repo.transactional(tenant, fn ->
  widget = Repo.insert!(
          %Product{id: "p1", name: "Widget", description: "You want to buy this!"}
        )
  r = [
        %Review{product: widget, author: "Alice", content: "It's ok", score: 3},
        %Review{product: widget, author: "Bob", content: "It's great!", score: 5}
      ]
  {widget, for(x <- r, do: Repo.insert!(x))}
end)
```

```elixir
{blivet, blivet_reviews} = 
  Repo.transactional(tenant, fn ->
  blivet = Repo.insert!(
          %Product{id: "p2", name: "Blivet", description: "It's pretty useful"}
        )
  r = [
        %Review{product: blivet, author: "Charlie", content: "The blivet is supreme", score: 5},
        %Review{product: blivet, author: "Dan", content: "This blivet is useless!", score: 1}
      ]
  {blivet, for(x <- r, do: Repo.insert!(x))}
end)
```

## Setup LiveView

Let's define a simple CSS stylesheet for our page. The values chosen here are not important for this demo.

```elixir
defmodule Style do
  def style() do
    """
    <style type="text/css">
      /* Global Resets & Layout */
      body { font-family: sans-serif; line-height: 1.5; color: #333; }
    
      /* Navigation Bar */
      .catalog ul {
        display: flex;
        justify-content: center;
        gap: 20px;
        padding: 1rem;
        list-style: none;
        background: #f4f4f4;
        border-bottom: 1px solid #ddd;
      }
      .catalog a { text-decoration: none; color: #007bff; font-weight: bold; }
      .catalog a:hover { text-decoration: underline; }
    
      /* Product Card */
      .card {
        max-width: 500px;
        margin: 2rem auto;
        padding: 2rem;
        border: 1px solid #eee;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      }
    
      .card h1 { text-align: center; margin-top: 0; }
      .card p { text-align: center; color: #666; }
    
      /* Reviews Section */
      .card ul { padding: 0; list-style: none; }
      .card figure {
        margin: 1.5rem 0;
        padding: 1rem;
        background: #fafafa;
        border-left: 4px solid #007bff;
      }
      blockquote { margin: 0; font-style: italic; }
      figcaption { text-align: right; font-weight: bold; font-size: 0.9rem; }
      
        /* Form Layout */
      .card form {
        display: flex;
        flex-direction: column;
        gap: 15px; /* Adds space between inputs and button */
        margin-top: 1rem;
      }
      
      /* Input Styling */
      .card input[type="text"] {
        width: 100%;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 1rem;
        box-sizing: border-box; /* Ensures padding doesn't break width */
      }
      
      .card input[type="text"]:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
      }
      
      /* Button Styling */
      .card button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
      }
    
      .card button:hover {
        background-color: #0056b3;
      }
    
      /* Label Styling */
      .card label {
        display: block;
        font-weight: bold;
        font-size: 0.85rem;
        color: #555;
        margin-bottom: -10px; /* Pulls the label closer to its specific input */
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      /* Add a bit of extra space between form groups */
      .card input + label {
        margin-top: 10px;
      }
    
      .page-title {
        text-align: center;
        margin: 2rem 0;
        font-size: 2rem;
        color: #222;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
    </style>
    """
  end
end
```

With the stylesheet out of the way, we can showcase how the Sync module works in your LiveView.

```elixir
defmodule DemoLive do
  use Phoenix.LiveView

  alias EctoFoundationDB.Sync
  import Ecto.Query

  @query_catalog from(p in Product, order_by: p.name)
  @query_reviews from(r in Review, order_by: {:desc, r.inserted_at})

  require Logger
  def mount(_params, _session, socket) do
    tenant = Tenant.open!(Repo, "sync-sample")

    {:ok, socket
      |> put_private(:tenant, tenant)
      |> Sync.sync_all(Repo, :catalog, @query_catalog)}
  end

  def handle_params(%{"id" => id}, _uri, socket) do
    {:noreply, 
      socket
      |> Sync.sync_one(Repo, :product, Product, id)
      |> Sync.sync_all_by(Repo, :reviews, @query_reviews, product_id: id)}
  end
  def handle_params(_params, _uri, socket),
    do: {:noreply, assign(socket, product: nil, reviews: [])}

  def render(assigns) do
    ~H"""
    <h1 class="page-title">Catalog</h1>
    <div class="catalog">
      <ul>
        <li :for={p <- @catalog}>
          <.link patch={"/?id=#{p.id}"}>{p.name}</.link>
        </li>
      </ul>
    </div>
    <div :if={@product} class="card">
      <h1>{@product.name}</h1>
      <p>{@product.description}</p>
      <ul>
        <li :for={r <- @reviews}>
          <figure>
            <blockquote>({ r.score } stars) { r.content }</blockquote>
            <h3><figcaption>- { r.author }</figcaption></h3>
          </figure>
        </li>
      </ul>
    </div>

    {Phoenix.HTML.raw(Style.style())}
    """
  end

end

PhoenixPlayground.start(live: DemoLive)
```

Now we can add anything to our database, and the page will update.

```elixir
foo = Repo.insert!(
  %Product{id: "p3", name: "Foo", description: "Hello world!"},
  prefix: tenant
)
```

```elixir
Repo.insert(%Review{product: foo, author: "Ethan", content: "Test", score: 3}, prefix: tenant)
```

### LiveComponents

Next, we're going to add another route to our phoenix app, so let's restart the `:phoenix_playground` to get a clean slate.

```elixir
Application.stop(:phoenix_playground)
Application.start(:phoenix_playground)
```

Our app needs an admin page, where we can modify product details. We're going to use LiveComponents for this part of the demo.

```elixir
defmodule ProductAdminCard do
  use Phoenix.LiveComponent
  require Logger

  def update(assigns, socket) do
    Logger.info("LC #{inspect(assigns)}")
    {:ok,
      socket
      |> assign(assigns)
      |> assign(form: to_form(Product.changeset(assigns.product)))}
  end
  
  def handle_event("save", %{"product" => params}, socket) do
    changeset = Product.changeset(socket.assigns.product, params)
    Repo.update!(changeset)
    {:noreply, socket}
  end

  def render(assigns) do
    ~H"""
    <div class="card">
      <.form
        for={@form}
        id={"product-form-#{@product.id}"}
        phx-submit="save"
        phx-target={@myself}
      >
        <label for={@form[:name].id}>Product Name</label>
        <input type="text" id={@form[:name].id} name={@form[:name].name} value={@form[:name].value} />
        <label for={@form[:description].id}>Description</label>
        <input type="text" id={@form[:description].id} name={@form[:description].name} value={@form[:description].value}} />
        <button>Save</button>
      </.form>
    </div>
    """
  end
end
```

```elixir
defmodule DemoAdminLive do
    use Phoenix.LiveView

  alias EctoFoundationDB.Sync
  import Ecto.Query

  require Logger

  @query_catalog from(p in Product, select: p.id)

  def mount(_params, _session, socket) do
    tenant = Tenant.open!(Repo, "sync-sample")

    {:ok, socket
      |> put_private(:tenant, tenant)
      |> Sync.attach_callback(Repo, :handle_assigns, &handle_assigns/2)
      |> Sync.sync_all(Repo, :catalog, @query_catalog, watch_action: :collection)}
  end

  def handle_assigns(socket, catalog: old_catalog) do
    id_deleted = for p <- (old_catalog || []),
      do: [:products, p]
    
    id_assigns = for p <- socket.assigns.catalog,
      do: {[:products, p], Product, p}

    {:halt, socket
      |> Sync.cancel_many(Repo, id_deleted)
      |> Sync.sync_many(Repo, id_assigns, replace: false)}
  end
  def handle_assigns(socket, _) do
    {:cont, socket}
  end

  def render(assigns) do
    ~H"""
    <h1 class="page-title">Admin</h1>
    <div :for={id <- @catalog}>
      <.live_component
          :if={@products[id]}
          module={ProductAdminCard}
          id={id}
          product={@products[id]} />
    </div>

    {Phoenix.HTML.raw(Style.style())}
    """
  end
end

defmodule DemoRouter do
  use Phoenix.Router
  import Phoenix.LiveView.Router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :put_root_layout, html: {PhoenixPlayground.Layout, :root}
    plug :put_secure_browser_headers
  end

  scope "/" do
    pipe_through :browser

    live "/", DemoLive
    live "/admin", DemoAdminLive
  end
end

PhoenixPlayground.start(plug: DemoRouter)
```

```elixir
Repo.delete!(widget, prefix: tenant)
:timer.sleep(500)
Repo.insert!(widget, prefix: tenant)
```
