# Sync Engine Part III - Removing boilerplate

```elixir
Mix.install([
  {:phoenix_playground, "~> 0.1"},
  {:ecto_foundationdb, github: "jessestimpson/ecto_foundationdb", branch: "sync"}
])
```

## Intro

Using [FoundationDB Watches](https://hexdocs.pm/ecto_foundationdb/Ecto.Adapters.FoundationDB.html#module-watches), we can set up a mini read-path Sync Engine. It will automatically propagate new data to all mounted LiveViews with push-messaging delivered from the database directly to the LiveView process.

This is Part III, where capture the ideas from I and II into a module that removes as much boilerplate as possible, and keeps your LiveView lean.

## Setup Ecto

First, we set up Ecto, defining a schema, and starting the Repo.

```elixir
defmodule Product do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: false}

  schema "products" do
    field(:name, :string)
    field(:description, :string)
    timestamps()
  end

  def changeset(product, params \\ %{}) do
    Changeset.cast(product, params, [:name, :description])
  end
end

defmodule Review do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}

  schema "reviews" do
    belongs_to(:product, Product, type: :binary_id)
    field(:author, :string)
    field(:content, :string)
    field(:score, :integer)
    timestamps()
  end

  def changeset(review, params \\ %{}) do
    Changeset.cast(review, params, [:author, :content, :score])
  end
end

defmodule Migration1 do
  use EctoFoundationDB.Migration

  @impl true
  def change() do
    [
      create(metadata(Product)),
      create(index(Product, [:name])),
      create(metadata(Review)),
      create(index(Review, [:product_id, :inserted_at])),
      create(metadata(Review, [:product_id]))
    ]
  end
end

defmodule Repo do
  use Ecto.Repo, otp_app: :my_app, adapter: Ecto.Adapters.FoundationDB

  use EctoFoundationDB.Migrator

  @impl true
  def migrations(), do: [
    {1, Migration1}
  ]
end

# ------------------------------------------------------------------
# This section contains some set-up within Livebook that's typically
# handled instead in your application startup and config.
Application.put_env(:my_app, Repo,
  open_db: &EctoFoundationDB.Sandbox.open_db/1,
  storage_id: EctoFoundationDB.Sandbox
)

{:ok, _} = Ecto.Adapters.FoundationDB.ensure_all_started(Repo.config(), :temporary)
Repo.start_link(log: false)
# ------------------------------------------------------------------

alias EctoFoundationDB.Tenant

Tenant.clear_delete!(Repo, "sync-sample")
tenant = Tenant.open_empty!(Repo, "sync-sample")

```

Next, we create a product and some reviews.

```elixir
{widget, widget_reviews} = 
  Repo.transactional(tenant, fn ->
  widget = Repo.insert!(
          %Product{id: "p1", name: "Widget", description: "You want to buy this!"}
        )
  r = [
        %Review{product: widget, author: "Alice", content: "It's ok", score: 3},
        %Review{product: widget, author: "Bob", content: "It's great!", score: 5}
      ]
  {widget, for(x <- r, do: Repo.insert!(x))}
end)
```

```elixir
{blivet, blivet_reviews} = 
  Repo.transactional(tenant, fn ->
  blivet = Repo.insert!(
          %Product{id: "p2", name: "Blivet", description: "It's pretty useful"}
        )
  r = [
        %Review{product: blivet, author: "Charlie", content: "The blivet is supreme", score: 5},
        %Review{product: blivet, author: "Dan", content: "This blivet is useless!", score: 1}
      ]
  {blivet, for(x <- r, do: Repo.insert!(x))}
end)
```

## Setup LiveView

Let's define a simple CSS stylesheet for our page. The values chosen here are not important for this demo.

```elixir
defmodule Style do
  def style(), do: """
<style type="text/css">
  /* Global Resets & Layout */
  body { font-family: sans-serif; line-height: 1.5; color: #333; }

  /* Navigation Bar */
  .catalog ul {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 1rem;
    list-style: none;
    background: #f4f4f4;
    border-bottom: 1px solid #ddd;
  }
  .catalog a { text-decoration: none; color: #007bff; font-weight: bold; }
  .catalog a:hover { text-decoration: underline; }

  /* Product Card */
  .card {
    max-width: 500px;
    margin: 2rem auto;
    padding: 2rem;
    border: 1px solid #eee;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }

  .card h1 { text-align: center; margin-top: 0; }
  .card p { text-align: center; color: #666; }

  /* Reviews Section */
  .card ul { padding: 0; list-style: none; }
  .card figure {
    margin: 1.5rem 0;
    padding: 1rem;
    background: #fafafa;
    border-left: 4px solid #007bff;
  }
  blockquote { margin: 0; font-style: italic; }
  figcaption { text-align: right; font-weight: bold; font-size: 0.9rem; }
</style>
"""
end
```

With the stylesheet out of the way, we can showcase how the Sync module works in your LiveView.

```elixir
defmodule DemoLive do
  use Phoenix.LiveView

  alias EctoFoundationDB.Sync
  import Ecto.Query

  require Logger
  def mount(_params, _session, socket) do
    tenant = Tenant.open!(Repo, "sync-sample")

    {:ok, socket
      |> put_private(:tenant, tenant)
      |> Sync.sync_all!(Repo, :catalog, from(p in Product, order_by: p.name))}
  end

  def handle_params(%{"id" => id}, _uri, socket) do
    {:noreply, 
      socket
      |> Sync.sync_one!(Repo, :product, Product, id)
      |> Sync.sync_all_by!(Repo, :reviews, Review, product_id: id)}
  end
  def handle_params(_params, _uri, socket),
    do: {:noreply, assign(socket, product: nil, reviews: [])}

  def render(assigns) do
    ~H"""
    <div class="catalog">
      <ul>
        <li :for={p <- @catalog}>
          <.link patch={"/?id=#{p.id}"}>{p.name}</.link>
        </li>
      </ul>
    </div>
    <div :if={@product} class="card">
      <h1>{@product.name}</h1>
      <p>{@product.description}</p>
      <ul>
        <li :for={r <- @reviews}>
          <figure>
            <blockquote>({ r.score } stars) { r.content }</blockquote>
            <h3><figcaption>- { r.author }</figcaption></h3>
          </figure>
        </li>
      </ul>
    </div>

    {Phoenix.HTML.raw(Style.style())}
    """
  end

end

PhoenixPlayground.start(live: DemoLive)
```

Now we can add anything to our database, and the page will update.

```elixir
foo = Repo.insert!(
  %Product{id: "p3", name: "Foo", description: "Hello world!"},
  prefix: tenant
)
```

```elixir
Repo.insert(%Review{product: foo, author: "Ethan", content: "Test", score: 3}, prefix: tenant)
```
