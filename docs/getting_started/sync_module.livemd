# Sync Engine Part III - Removing boilerplate

```elixir
Mix.install([
  {:phoenix_playground, "~> 0.1.0"},
  {:ecto_foundationdb, github: "jessestimpson/ecto_foundationdb", branch: "sync"}
])
```

## Intro

Using [FoundationDB Watches](https://hexdocs.pm/ecto_foundationdb/Ecto.Adapters.FoundationDB.html#module-watches), we can set up a mini read-path Sync Engine. It will automatically propagate new data to all mounted LiveViews with push-messaging delivered from the database directly to the LiveView process.

This is Part III, where capture the ideas from I and II into a module that removes as much boilerplate as possible, and keeps your LiveView lean.

## Setup Ecto

First, we set up Ecto, defining a schema, and starting the Repo.

```elixir
defmodule Product do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}

  schema "products" do
    field(:name, :string)
    field(:description, :string)
    timestamps()
  end

  def changeset(quote, params \\ %{}) do
    quote
    |> Changeset.cast(params, [:name, :description])
  end
end

defmodule Review do
  use Ecto.Schema

  alias Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}

  schema "reviews" do
    belongs_to(:product, Product, type: :binary_id)
    field(:author, :string)
    field(:content, :string)
    field(:score, :integer)
    timestamps()
  end

  def changeset(quote, params \\ %{}) do
    quote
    |> Changeset.cast(params, [:author, :content, :score])
  end
end

defmodule Migration1 do
  use EctoFoundationDB.Migration

  @impl true
  def change() do
    [
      create(metadata(Product)),
      create(index(Product, [:name])),
      create(metadata(Review)),
      create(index(Review, [:product_id, :inserted_at])),
      create(metadata(Review, [:product_id]))
    ]
  end
end

defmodule Repo do
  use Ecto.Repo, otp_app: :my_app, adapter: Ecto.Adapters.FoundationDB

  use EctoFoundationDB.Migrator

  @impl true
  def migrations(), do: [
    {1, Migration1}
  ]
end

# ------------------------------------------------------------------
# This section contains some set-up within Livebook that's typically
# handled instead in your application startup and config.
Application.put_env(:my_app, Repo,
  open_db: &EctoFoundationDB.Sandbox.open_db/1,
  storage_id: EctoFoundationDB.Sandbox
)

{:ok, _} = Ecto.Adapters.FoundationDB.ensure_all_started(Repo.config(), :temporary)
Repo.start_link(log: false)
# ------------------------------------------------------------------

alias EctoFoundationDB.Tenant

Tenant.clear_delete!(Repo, "sync-sample")
tenant = Tenant.open_empty!(Repo, "sync-sample")

```

Next, we create a product and some reviews.

```elixir
{widget, widget_reviews} = 
  Repo.transactional(tenant, fn ->
  widget = case Repo.get_by(Product, name: "Widget") do
    nil ->
        Repo.insert!(
          %Product{name: "Widget", description: "You want to buy this!"}
        )
    w ->
      w
  end

  case Repo.all_by(Review, product_id: widget.id) do
    [] ->
      r = [
        %Review{product: widget, author: "Alice", content: "It's ok", score: 3},
        %Review{product: widget, author: "Bob", content: "It's great!", score: 5}
      ]
      {widget, for(x <- r, do: Repo.insert!(x))}
    r ->
      {widget, r}
  end

end)
```

```elixir
{blivet, blivet_reviews} = 
  Repo.transactional(tenant, fn ->
  blivet = case Repo.get_by(Product, name: "Blivet") do
    nil ->
        Repo.insert!(
          %Product{name: "Blivet", description: "It's pretty useful"}
        )
    b ->
      b
  end

  case Repo.all_by(Review, product_id: blivet.id) do
    [] ->
      r = [
        %Review{product: blivet, author: "Charlie", content: "The blivet is supreme", score: 5},
        %Review{product: blivet, author: "Dan", content: "This blivet is useless!", score: 1}
      ]
      {blivet, for(x <- r, do: Repo.insert!(x))}
    r ->
      {blivet, r}
  end

end)
```

## Setup LiveView

```elixir
defmodule DemoLive do
  use Phoenix.LiveView

  alias EctoFoundationDB.Sync

  require Logger
  def mount(%{"id" => id}, _session, socket) do
    tenant = Tenant.open!(Repo, "sync-sample")

    # @todo: watching collections per tenant is just not good enough. Can we
    # watch collections per index value?
    {:ok, socket
      |> put_private(:tenant, tenant)
      |> Sync.sync_one!(Repo, Product, :product, id)
      |> Sync.sync_all!(Repo, Review, :reviews)}
  end

  def handle_params(%{"id" => id}, socket) do
    {:ok, socket
      |> Sync.sync_one!(Repo, Product, :product, id)}
  end

  def terminate(_reason, socket) do
    Sync.cancel_all(socket, Repo)
  end

  def render(assigns) do
    ~H"""
    <div class="content">
      <h1>{@product.name}</h1>
      <p>
      {@product.description}
      </p>
      <ul>
        <li :for={r <- @reviews}>
          <figure>
            <blockquote>({ r.score } stars) { r.content }</blockquote>
            <h3><figcaption>- { r.author }</figcaption></h3>
          </figure>
        </li>
      </ul>
    </div>

    <style type="text/css">
      h1 { text-align: center; }
      h3 { text-align: right; }
      h6 { text-align: right; }
      p { text-align: center; }
      ul li { list-style-type: none; }

      .content {
        max-width: 500px;
        margin: auto;
      }
    </style>
    """
  end

end

PhoenixPlayground.start(live: DemoLive, open_browser: false)
```

```elixir
IO.puts("http://localhost:4000?id=#{widget.id}")
```
